// controllers/admin/dashboardController.js
import HTTP from "../../constants/httpStatusCodes.js";
import EnterpriseClient from "../../models/enterprise/client.js";
import EnterpriseClientPackage from "../../models/enterprise/clientPackage.js";
import EnterpriseClientEvent from "../../models/enterprise/event.js";
import EnterprisePackageHistory from "../../models/enterprise/packageHistory.js";
import {
  AccountStatus,
  EventStatus,
  OnlineRoleType,
  PaymentStatus,
  VerifyType,
} from "../../utils/enums/index.js";
import { jsonOne } from "../../utils/generalUtils.js";

// ============================================
// HELPER: Get Date Range
// ============================================
const getDateRange = (period, customStart, customEnd) => {
  const now = new Date();
  let startDate, endDate, compareStartDate, compareEndDate;

  switch (period) {
    case "today":
      startDate = new Date(now.setHours(0, 0, 0, 0));
      endDate = new Date(now.setHours(23, 59, 59, 999));
      compareStartDate = new Date(startDate);
      compareStartDate.setDate(compareStartDate.getDate() - 1);
      compareEndDate = new Date(endDate);
      compareEndDate.setDate(compareEndDate.getDate() - 1);
      break;

    case "yesterday":
      startDate = new Date(now.setDate(now.getDate() - 1));
      startDate.setHours(0, 0, 0, 0);
      endDate = new Date(startDate);
      endDate.setHours(23, 59, 59, 999);
      compareStartDate = new Date(startDate);
      compareStartDate.setDate(compareStartDate.getDate() - 1);
      compareEndDate = new Date(endDate);
      compareEndDate.setDate(compareEndDate.getDate() - 1);
      break;

    case "week":
      startDate = new Date(now.setDate(now.getDate() - 7));
      endDate = new Date();
      compareStartDate = new Date(startDate);
      compareStartDate.setDate(compareStartDate.getDate() - 7);
      compareEndDate = new Date(startDate);
      break;

    case "month":
      startDate = new Date(now.getFullYear(), now.getMonth(), 1);
      endDate = new Date();
      compareStartDate = new Date(now.getFullYear(), now.getMonth() - 1, 1);
      compareEndDate = new Date(
        now.getFullYear(),
        now.getMonth(),
        0,
        23,
        59,
        59
      );
      break;

    case "lastMonth":
      startDate = new Date(now.getFullYear(), now.getMonth() - 1, 1);
      endDate = new Date(now.getFullYear(), now.getMonth(), 0, 23, 59, 59);
      compareStartDate = new Date(now.getFullYear(), now.getMonth() - 2, 1);
      compareEndDate = new Date(
        now.getFullYear(),
        now.getMonth() - 1,
        0,
        23,
        59,
        59
      );
      break;

    case "year":
      startDate = new Date(now.getFullYear(), 0, 1);
      endDate = new Date();
      compareStartDate = new Date(now.getFullYear() - 1, 0, 1);
      compareEndDate = new Date(now.getFullYear() - 1, 11, 31, 23, 59, 59);
      break;

    case "custom":
      startDate = new Date(customStart);
      endDate = new Date(customEnd);
      const diffTime = Math.abs(endDate - startDate);
      compareStartDate = new Date(startDate);
      compareStartDate.setTime(compareStartDate.getTime() - diffTime);
      compareEndDate = new Date(startDate);
      break;

    default:
      startDate = new Date(now.getFullYear(), now.getMonth(), 1);
      endDate = new Date();
      compareStartDate = new Date(now.getFullYear(), now.getMonth() - 1, 1);
      compareEndDate = new Date(
        now.getFullYear(),
        now.getMonth(),
        0,
        23,
        59,
        59
      );
  }

  return { startDate, endDate, compareStartDate, compareEndDate };
};

// ============================================
// 1. DASHBOARD OVERVIEW - SINGLE AGGREGATION
// ============================================
const getDashboardOverview = async (req, res, next) => {
  try {
    // SINGLE AGGREGATION FOR CLIENTS
    const clientStats = await EnterpriseClient.aggregate([
      {
        $facet: {
          counts: [
            { $match: { deletedAt: null } },
            {
              $group: {
                _id: null,
                total: { $sum: 1 },
                active: {
                  $sum: {
                    $cond: [{ $eq: ["$status", AccountStatus.ACTIVATE] }, 1, 0],
                  },
                },
                verified: {
                  $sum: {
                    $cond: [{ $eq: ["$verify", VerifyType.VERIFIED] }, 1, 0],
                  },
                },
                online: {
                  $sum: {
                    $cond: [
                      { $eq: ["$is_Online", OnlineRoleType.ONLINE] },
                      1,
                      0,
                    ],
                  },
                },
              },
            },
          ],
        },
      },
    ]);

    // SINGLE AGGREGATION FOR EVENTS & STORAGE
    const eventStats = await EnterpriseClientEvent.aggregate([
      {
        $facet: {
          counts: [
            { $match: { deletedAt: null } },
            {
              $group: {
                _id: null,
                total: { $sum: 1 },
                active: {
                  $sum: {
                    $cond: [{ $eq: ["$status", EventStatus.ACTIVE] }, 1, 0],
                  },
                },
                totalMB: { $sum: "$totalMBUsed" },
                totalPhotos: { $sum: "$totalPhotos" },
              },
            },
          ],
        },
      },
    ]);

    // SINGLE AGGREGATION FOR PACKAGES
    const packageStats = await EnterpriseClientPackage.aggregate([
      {
        $facet: {
          counts: [
            {
              $group: {
                _id: null,
                active: {
                  $sum: { $cond: [{ $eq: ["$isActive", true] }, 1, 0] },
                },
                trial: {
                  $sum: {
                    $cond: [
                      {
                        $and: [
                          { $eq: ["$isTrial", true] },
                          { $eq: ["$isActive", true] },
                        ],
                      },
                      1,
                      0,
                    ],
                  },
                },
              },
            },
          ],
        },
      },
    ]);

    // ✅ ENHANCED REVENUE & PROFIT AGGREGATION BY CURRENCY
    const revenueStats = await EnterprisePackageHistory.aggregate([
      {
        $match: {
          "paymentDetails.paymentStatus": PaymentStatus.COMPLETED,
        },
      },
      {
        $facet: {
          // INR Statistics
          INR: [
            {
              $match: { "paymentDetails.currency": "INR" },
            },
            {
              $group: {
                _id: null,
                totalRevenue: { $sum: "$paymentDetails.amountPaid" },
                totalOriginalAmount: {
                  $sum: "$paymentDetails.packageOriginalPrice",
                },
                totalDiscounts: {
                  $sum: "$paymentDetails.packageDiscountAmount",
                },
                totalCreditApplied: {
                  $sum: "$paymentDetails.proratedCreditApplied",
                },
                totalCreditLost: { $sum: "$paymentDetails.proratedCreditLost" },
                totalRazorpayFees: {
                  $sum: { $divide: ["$paymentDetails.fee", 100] },
                },
                totalRazorpayTax: {
                  $sum: { $divide: ["$paymentDetails.tax", 100] },
                },
                transactionCount: { $sum: 1 },
              },
            },
          ],

          // USD Statistics
          USD: [
            {
              $match: { "paymentDetails.currency": "USD" },
            },
            {
              $group: {
                _id: null,
                totalRevenue: { $sum: "$paymentDetails.amountPaid" },
                totalOriginalAmount: {
                  $sum: "$paymentDetails.packageOriginalPrice",
                },
                totalDiscounts: {
                  $sum: "$paymentDetails.packageDiscountAmount",
                },
                totalCreditApplied: {
                  $sum: "$paymentDetails.proratedCreditApplied",
                },
                totalCreditLost: { $sum: "$paymentDetails.proratedCreditLost" },
                totalRazorpayFees: {
                  $sum: { $divide: ["$paymentDetails.fee", 100] },
                },
                totalRazorpayTax: {
                  $sum: { $divide: ["$paymentDetails.tax", 100] },
                },
                transactionCount: { $sum: 1 },
              },
            },
          ],

          // Combined totals
          totals: [
            {
              $group: {
                _id: null,
                totalTransactions: { $sum: 1 },
                totalRevenueAllCurrencies: {
                  $sum: "$paymentDetails.amountPaid",
                },
              },
            },
          ],
        },
      },
    ]);

    const clients = clientStats[0].counts[0] || {
      total: 0,
      active: 0,
      verified: 0,
      online: 0,
    };
    const events = eventStats[0].counts[0] || {
      total: 0,
      active: 0,
      totalMB: 0,
      totalPhotos: 0,
    };
    const packages = packageStats[0].counts[0] || {
      active: 0,
      trial: 0,
    };

    // Extract revenue data with defaults
    const inrData = revenueStats[0].INR[0] || {
      totalRevenue: 0,
      totalOriginalAmount: 0,
      totalDiscounts: 0,
      totalCreditApplied: 0,
      totalCreditLost: 0,
      totalRazorpayFees: 0,
      totalRazorpayTax: 0,
      transactionCount: 0,
    };

    const usdData = revenueStats[0].USD[0] || {
      totalRevenue: 0,
      totalOriginalAmount: 0,
      totalDiscounts: 0,
      totalCreditApplied: 0,
      totalCreditLost: 0,
      totalRazorpayFees: 0,
      totalRazorpayTax: 0,
      transactionCount: 0,
    };

    const totals = revenueStats[0].totals[0] || {
      totalTransactions: 0,
      totalRevenueAllCurrencies: 0,
    };

    return await jsonOne(res, HTTP.SUCCESS, {
      clients: {
        total: clients.total,
        active: clients.active,
        verified: clients.verified,
        online: clients.online,
      },
      events: { total: events.total, active: events.active },
      packages: { active: packages.active, trial: packages.trial },
      storage: {
        totalGB: (events.totalMB / 1024).toFixed(2),
        totalPhotos: events.totalPhotos,
      },
      revenue: {
        // INR Breakdown
        INR: {
          totalRevenue: inrData.totalRevenue,
          totalOriginalAmount: inrData.totalOriginalAmount,
          totalDiscounts: inrData.totalDiscounts,
          totalCreditApplied: inrData.totalCreditApplied,
          totalCreditLost: inrData.totalCreditLost,
          totalRazorpayFees: inrData.totalRazorpayFees,
          totalRazorpayTax: inrData.totalRazorpayTax,
          transactionCount: inrData.transactionCount,
          symbol: "₹",
        },
        // USD Breakdown
        USD: {
          totalRevenue: usdData.totalRevenue,
          totalOriginalAmount: usdData.totalOriginalAmount,
          totalDiscounts: usdData.totalDiscounts,
          totalCreditApplied: usdData.totalCreditApplied,
          totalCreditLost: usdData.totalCreditLost,
          totalRazorpayFees: usdData.totalRazorpayFees,
          totalRazorpayTax: usdData.totalRazorpayTax,
          transactionCount: usdData.transactionCount,
          symbol: "$",
        },
        // Combined Summary
        totalTransactions: totals.totalTransactions,
      },
    });
  } catch (error) {
    next(error);
  }
};

// ============================================
// 2. REVENUE CHART - WITH INR & USD SEPARATION
// ============================================
const getDashboardRevenueChart = async (req, res, next) => {
  try {
    const {
      period = "month",
      startDate: customStart,
      endDate: customEnd,
    } = req.query;
    const { startDate, endDate, compareStartDate, compareEndDate } =
      getDateRange(period, customStart, customEnd);

    const data = await EnterprisePackageHistory.aggregate([
      {
        $facet: {
          // Current Period - INR
          currentINR: [
            {
              $match: {
                "paymentDetails.paymentStatus": PaymentStatus.COMPLETED,
                "paymentDetails.currency": "INR",
                "paymentDetails.paymentDate": {
                  $gte: startDate,
                  $lte: endDate,
                },
              },
            },
            {
              $group: {
                _id: {
                  $dateToString: {
                    format: "%Y-%m-%d",
                    date: "$paymentDetails.paymentDate",
                  },
                },
                revenue: { $sum: "$paymentDetails.amountPaid" },
                count: { $sum: 1 },
              },
            },
            { $sort: { _id: 1 } },
          ],

          // Current Period - USD
          currentUSD: [
            {
              $match: {
                "paymentDetails.paymentStatus": PaymentStatus.COMPLETED,
                "paymentDetails.currency": "USD",
                "paymentDetails.paymentDate": {
                  $gte: startDate,
                  $lte: endDate,
                },
              },
            },
            {
              $group: {
                _id: {
                  $dateToString: {
                    format: "%Y-%m-%d",
                    date: "$paymentDetails.paymentDate",
                  },
                },
                revenue: { $sum: "$paymentDetails.amountPaid" },
                count: { $sum: 1 },
              },
            },
            { $sort: { _id: 1 } },
          ],

          // Compare Period - INR
          compareINR: [
            {
              $match: {
                "paymentDetails.paymentStatus": PaymentStatus.COMPLETED,
                "paymentDetails.currency": "INR",
                "paymentDetails.paymentDate": {
                  $gte: compareStartDate,
                  $lte: compareEndDate,
                },
              },
            },
            {
              $group: {
                _id: null,
                revenue: { $sum: "$paymentDetails.amountPaid" },
              },
            },
          ],

          // Compare Period - USD
          compareUSD: [
            {
              $match: {
                "paymentDetails.paymentStatus": PaymentStatus.COMPLETED,
                "paymentDetails.currency": "USD",
                "paymentDetails.paymentDate": {
                  $gte: compareStartDate,
                  $lte: compareEndDate,
                },
              },
            },
            {
              $group: {
                _id: null,
                revenue: { $sum: "$paymentDetails.amountPaid" },
              },
            },
          ],
        },
      },
    ]);

    // Extract data
    const currentINRData = data[0].currentINR;
    const currentUSDData = data[0].currentUSD;

    // Calculate totals
    const currentINRTotal = currentINRData.reduce(
      (sum, item) => sum + item.revenue,
      0
    );
    const currentUSDTotal = currentUSDData.reduce(
      (sum, item) => sum + item.revenue,
      0
    );

    const compareINRTotal = data[0].compareINR[0]?.revenue || 0;
    const compareUSDTotal = data[0].compareUSD[0]?.revenue || 0;

    // Calculate percentage changes
    const inrPercentChange =
      compareINRTotal > 0
        ? (
            ((currentINRTotal - compareINRTotal) / compareINRTotal) *
            100
          ).toFixed(2)
        : 0;

    const usdPercentChange =
      compareUSDTotal > 0
        ? (
            ((currentUSDTotal - compareUSDTotal) / compareUSDTotal) *
            100
          ).toFixed(2)
        : 0;

    // Get all unique dates from both currencies
    const allDates = [
      ...new Set([
        ...currentINRData.map((item) => item._id),
        ...currentUSDData.map((item) => item._id),
      ]),
    ].sort();

    // Create aligned data for both currencies
    const chartDataINR = allDates.map((date) => {
      const dataPoint = currentINRData.find((item) => item._id === date);
      return {
        _id: date,
        revenue: dataPoint?.revenue || 0,
        count: dataPoint?.count || 0,
      };
    });

    const chartDataUSD = allDates.map((date) => {
      const dataPoint = currentUSDData.find((item) => item._id === date);
      return {
        _id: date,
        revenue: dataPoint?.revenue || 0,
        count: dataPoint?.count || 0,
      };
    });

    return await jsonOne(res, HTTP.SUCCESS, {
      chartData: allDates, // Common labels
      INR: {
        data: chartDataINR,
        total: currentINRTotal,
        previous: compareINRTotal,
        percentChange: parseFloat(inrPercentChange),
        isIncrease: inrPercentChange >= 0,
        symbol: "₹",
      },
      USD: {
        data: chartDataUSD,
        total: currentUSDTotal,
        previous: compareUSDTotal,
        percentChange: parseFloat(usdPercentChange),
        isIncrease: usdPercentChange >= 0,
        symbol: "$",
      },
      summary: {
        currentINR: currentINRTotal,
        currentUSD: currentUSDTotal,
        previousINR: compareINRTotal,
        previousUSD: compareUSDTotal,
      },
      period: { startDate, endDate, compareStartDate, compareEndDate },
    });
  } catch (error) {
    next(error);
  }
};

// ============================================
// 3. CLIENT GROWTH CHART - OPTIMIZED
// ============================================
const getDashboardClientGrowthChart = async (req, res, next) => {
  try {
    const {
      period = "month",
      startDate: customStart,
      endDate: customEnd,
    } = req.query;
    const { startDate, endDate, compareStartDate, compareEndDate } =
      getDateRange(period, customStart, customEnd);

    const data = await EnterpriseClient.aggregate([
      {
        $facet: {
          currentPeriod: [
            {
              $match: {
                createdAt: { $gte: startDate, $lte: endDate },
                deletedAt: null,
              },
            },
            {
              $group: {
                _id: {
                  $dateToString: { format: "%Y-%m-%d", date: "$createdAt" },
                },
                count: { $sum: 1 },
              },
            },
            { $sort: { _id: 1 } },
          ],
          comparePeriod: [
            {
              $match: {
                createdAt: { $gte: compareStartDate, $lte: compareEndDate },
                deletedAt: null,
              },
            },
            { $count: "count" },
          ],
        },
      },
    ]);

    const currentData = data[0].currentPeriod;
    const currentTotal = currentData.reduce((sum, item) => sum + item.count, 0);
    const compareTotal = data[0].comparePeriod[0]?.count || 0;
    const percentChange =
      compareTotal > 0
        ? (((currentTotal - compareTotal) / compareTotal) * 100).toFixed(2)
        : 0;

    return await jsonOne(res, HTTP.SUCCESS, {
      chartData: currentData,
      summary: {
        current: currentTotal,
        previous: compareTotal,
        percentChange: parseFloat(percentChange),
        isIncrease: percentChange >= 0,
      },
      period: { startDate, endDate, compareStartDate, compareEndDate },
    });
  } catch (error) {
    next(error);
  }
};

// ============================================
// 4. EVENTS CHART - OPTIMIZED
// ============================================
const getDashboardEventsChart = async (req, res, next) => {
  try {
    const {
      period = "month",
      startDate: customStart,
      endDate: customEnd,
    } = req.query;
    const { startDate, endDate, compareStartDate, compareEndDate } =
      getDateRange(period, customStart, customEnd);

    const data = await EnterpriseClientEvent.aggregate([
      {
        $facet: {
          currentPeriod: [
            {
              $match: {
                createdAt: { $gte: startDate, $lte: endDate },
                deletedAt: null,
              },
            },
            {
              $group: {
                _id: {
                  $dateToString: { format: "%Y-%m-%d", date: "$createdAt" },
                },
                count: { $sum: 1 },
              },
            },
            { $sort: { _id: 1 } },
          ],
          comparePeriod: [
            {
              $match: {
                createdAt: { $gte: compareStartDate, $lte: compareEndDate },
                deletedAt: null,
              },
            },
            { $count: "count" },
          ],
        },
      },
    ]);

    const currentData = data[0].currentPeriod;
    const currentTotal = currentData.reduce((sum, item) => sum + item.count, 0);
    const compareTotal = data[0].comparePeriod[0]?.count || 0;
    const percentChange =
      compareTotal > 0
        ? (((currentTotal - compareTotal) / compareTotal) * 100).toFixed(2)
        : 0;

    return await jsonOne(res, HTTP.SUCCESS, {
      chartData: currentData,
      summary: {
        current: currentTotal,
        previous: compareTotal,
        percentChange: parseFloat(percentChange),
        isIncrease: percentChange >= 0,
      },
      period: { startDate, endDate, compareStartDate, compareEndDate },
    });
  } catch (error) {
    next(error);
  }
};

// ============================================
// 5. STORAGE CHART - OPTIMIZED
// ============================================
const getDashboardStorageUsageChart = async (req, res, next) => {
  try {
    const {
      period = "month",
      startDate: customStart,
      endDate: customEnd,
    } = req.query;
    const { startDate, endDate, compareStartDate, compareEndDate } =
      getDateRange(period, customStart, customEnd);

    const data = await EnterpriseClientEvent.aggregate([
      {
        $facet: {
          currentPeriod: [
            {
              $match: {
                createdAt: { $gte: startDate, $lte: endDate },
                deletedAt: null,
              },
            },
            {
              $group: {
                _id: {
                  $dateToString: { format: "%Y-%m-%d", date: "$createdAt" },
                },
                totalMB: { $sum: "$totalMBUsed" },
                totalPhotos: { $sum: "$totalPhotos" },
              },
            },
            { $sort: { _id: 1 } },
          ],
          comparePeriod: [
            {
              $match: {
                createdAt: { $gte: compareStartDate, $lte: compareEndDate },
                deletedAt: null,
              },
            },
            {
              $group: {
                _id: null,
                totalMB: { $sum: "$totalMBUsed" },
              },
            },
          ],
        },
      },
    ]);

    const currentData = data[0].currentPeriod;
    const currentTotalMB = currentData.reduce(
      (sum, item) => sum + item.totalMB,
      0
    );
    const compareTotalMB = data[0].comparePeriod[0]?.totalMB || 0;
    const percentChange =
      compareTotalMB > 0
        ? (((currentTotalMB - compareTotalMB) / compareTotalMB) * 100).toFixed(
            2
          )
        : 0;

    return await jsonOne(res, HTTP.SUCCESS, {
      chartData: currentData,
      summary: {
        currentMB: currentTotalMB,
        currentGB: (currentTotalMB / 1024).toFixed(2),
        previousMB: compareTotalMB,
        previousGB: (compareTotalMB / 1024).toFixed(2),
        percentChange: parseFloat(percentChange),
        isIncrease: percentChange >= 0,
      },
      period: { startDate, endDate, compareStartDate, compareEndDate },
    });
  } catch (error) {
    next(error);
  }
};

// ============================================
// 6. TOP PACKAGES - ALREADY OPTIMIZED
// ============================================
const getDashboardTopPackages = async (req, res, next) => {
  try {
    const topPackages = await EnterprisePackageHistory.aggregate([
      { $match: { "paymentDetails.paymentStatus": PaymentStatus.COMPLETED } },
      {
        $lookup: {
          from: "enterprisepackages",
          localField: "packageId",
          foreignField: "_id",
          as: "packageInfo",
        },
      },
      { $unwind: "$packageInfo" },
      {
        $group: {
          _id: "$packageId",
          packageName: { $first: "$packageInfo.packageName" },
          totalRevenue: { $sum: "$paymentDetails.amountPaid" },
          subscriberCount: { $sum: 1 },
        },
      },
      { $sort: { totalRevenue: -1 } },
      { $limit: 5 },
    ]);

    return await jsonOne(res, HTTP.SUCCESS, topPackages);
  } catch (error) {
    next(error);
  }
};

// ============================================
// 7. TOP CLIENTS - ALREADY OPTIMIZED
// ============================================
const getDashboardTopClients = async (req, res, next) => {
  try {
    const topClients = await EnterpriseClientEvent.aggregate([
      { $match: { deletedAt: null } },
      {
        $group: {
          _id: "$enterpriseClientId",
          totalMB: { $sum: "$totalMBUsed" },
          totalEvents: { $sum: 1 },
          totalPhotos: { $sum: "$totalPhotos" },
        },
      },
      {
        $lookup: {
          from: "enterpriseclients",
          localField: "_id",
          foreignField: "_id",
          as: "clientInfo",
        },
      },
      { $unwind: "$clientInfo" },
      {
        $project: {
          clientName: "$clientInfo.fullName",
          clientEmail: "$clientInfo.email",
          clientImage: "$clientInfo.image",
          totalMB: 1,
          totalGB: { $divide: ["$totalMB", 1024] },
          totalEvents: 1,
          totalPhotos: 1,
        },
      },
      { $sort: { totalMB: -1 } },
      { $limit: 10 },
    ]);

    return await jsonOne(res, HTTP.SUCCESS, topClients);
  } catch (error) {
    next(error);
  }
};

// ============================================
// 8. RECENT REGISTRATIONS - ALREADY OPTIMIZED
// ============================================
const getDashboardRecentRegistrations = async (req, res, next) => {
  try {
    const recentClients = await EnterpriseClient.find({
      createdAt: { $gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000) },
      deletedAt: null,
    })
      .select("fullName email image status verify createdAt")
      .sort({ createdAt: -1 })
      .limit(10)
      .lean();

    return await jsonOne(res, HTTP.SUCCESS, recentClients);
  } catch (error) {
    next(error);
  }
};

export default {
  getDashboardOverview,
  getDashboardRevenueChart,
  getDashboardClientGrowthChart,
  getDashboardEventsChart,
  getDashboardStorageUsageChart,
  getDashboardTopPackages,
  getDashboardTopClients,
  getDashboardRecentRegistrations,
};
