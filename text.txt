import crypto from "crypto";
import CameraToken from "../../models/enterprise/cameraToken.js";
import CameraConnection from "../../models/enterprise/cameraConnection.js";
import config from "../../config/config.js";
import { jsonOne, throwHttpError } from "../../utils/generalUtils.js";
import HTTP from "../../constants/httpStatusCodes.js";
import { getIO } from "../../socket/socket.js";
import { AccountStatus } from "../../utils/enums/index.js";
import { updateCameraState } from "../../ftp/ftpServer.js";

// ✅ Generate new camera token (photographer does this once per camera)
const createCameraToken = async (req, res, next) => {
  try {
    const { id: enterpriseClientId } = req.tokenPayload;
    const { tokenName } = req.body; // e.g. "Canon R5 - Main Camera"

    // Generate unique FTP credentials
    const ftpUsername = `cam_${crypto.randomBytes(6).toString("hex")}`; // cam_a3f9b2c1d4e5
    const ftpPassword = crypto.randomBytes(8).toString("hex"); // b2c1d4e5f6a7b8c9

    const token = await CameraToken.create({
      enterpriseClientId,
      tokenName,
      ftpUsername,
      ftpPassword,
    });

    const connection = await CameraConnection.create({
      enterpriseClientId,
      cameraTokenId: token._id,
      tokenName: token.tokenName,
      isOnline: false,
      isUploadEnabled: true,
      totalUploaded: 0,
    });

    return jsonOne(res, HTTP.SUCCESS, {
      connectionId: connection._id,
      cameraTokenId: token._id,
      tokenName: token.tokenName,
      isOnline: false,
      isUploadEnabled: true,
      totalUploaded: 0,
      assignedEventId: null,
      assignedAlbumId: null,
      ftpCredentials: {
        host: config.ftp.publicHost,
        port: config.ftp.port,
        username: ftpUsername,
        password: ftpPassword,
      },
      cameraSetupGuide: {
        canon:
          "Menu → Network → FTP Transfer Settings → enter host/port/user/pass",
        nikon: "Menu → Network → Connect to FTP Server → enter credentials",
        sony: "Menu → Network → FTP Transfer Func → Server Settings",
        fujifilm: "Menu → Wireless Settings → FTP Uploading → Server Settings",
      },
    });
  } catch (error) {
    next(error);
  }
};

// ✅ Get all cameras of this client (connected + offline)
const getCameraList = async (req, res, next) => {
  try {
    const { id: enterpriseClientId } = req.tokenPayload;

    const cameras = await CameraConnection.find({ enterpriseClientId })
      .populate("assignedEventId", "eventName slug")
      .populate("assignedAlbumId", "albumName totalImages")
      .sort({ isOnline: -1, lastSeenAt: -1 })
      .lean();

    return jsonOne(res, HTTP.SUCCESS, cameras);
  } catch (error) {
    next(error);
  }
};

// ✅ Assign event + album to camera
const assignEventAlbum = async (req, res, next) => {
  try {
    const { cameraConnectionId } = req.params;
    const { assignedEventId, assignedAlbumId } = req.body;
    const { id: enterpriseClientId } = req.tokenPayload;

    const camera = await CameraConnection.findOneAndUpdate(
      { _id: cameraConnectionId, enterpriseClientId },
      { assignedEventId, assignedAlbumId },
      { new: true },
    )
      .populate("assignedEventId", "eventName")
      .populate("assignedAlbumId", "albumName");

    if (!camera) {
      return throwHttpError("not_found", "Camera not found", HTTP.NOT_FOUND);
    }

    updateCameraState(cameraConnectionId, {
      assignedEventId,
      assignedAlbumId,
    });

    // ✅ Emit update to dashboard
    const io = getIO();
    io.to(`client_${enterpriseClientId}`).emit("camera_updated", {
      cameraConnectionId,
      assignedEventId: camera.assignedEventId,
      assignedAlbumId: camera.assignedAlbumId,
    });

    return jsonOne(res, HTTP.SUCCESS, camera);
  } catch (error) {
    next(error);
  }
};

// ✅ Enable / Disable upload toggle
const toggleCameraUpload = async (req, res, next) => {
  try {
    const { cameraConnectionId } = req.params;
    const { id: enterpriseClientId } = req.tokenPayload;

    const camera = await CameraConnection.findOne({
      _id: cameraConnectionId,
      enterpriseClientId,
    });

    if (!camera) {
      return throwHttpError("not_found", "Camera not found", HTTP.NOT_FOUND);
    }

    camera.isUploadEnabled = !camera.isUploadEnabled;
    await camera.save();

    updateCameraState(cameraConnectionId, {
      isUploadEnabled: camera.isUploadEnabled,
    });

    // ✅ Emit toggle to dashboard
    const io = getIO();
    io.to(`client_${enterpriseClientId}`).emit("camera_updated", {
      cameraConnectionId,
      isUploadEnabled: camera.isUploadEnabled,
    });

    return jsonOne(res, HTTP.SUCCESS, {
      cameraConnectionId,
      isUploadEnabled: camera.isUploadEnabled,
    });
  } catch (error) {
    next(error);
  }
};

// ✅ Delete camera token
const deleteCameraToken = async (req, res, next) => {
  try {
    const { tokenId } = req.params;
    const { id: enterpriseClientId } = req.tokenPayload;

    await CameraToken.findOneAndUpdate(
      { _id: tokenId, enterpriseClientId },
      { deletedAt: new Date(), status: AccountStatus.DEACTIVE },
    );

    // ✅ Also delete the connection record so it's removed from list
    await CameraConnection.findOneAndDelete({ cameraTokenId: tokenId });

    return jsonOne(res, HTTP.SUCCESS, {}, "Camera removed");
  } catch (error) {
    next(error);
  }
};

export default {
  createCameraToken,
  getCameraList,
  assignEventAlbum,
  toggleCameraUpload,
  deleteCameraToken,
};
