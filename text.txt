import FtpSrv from "ftp-srv";
import path from "path";
import fs from "fs";
import os from "os";
import CameraToken from "../models/enterprise/cameraToken.js";
import CameraConnection from "../models/enterprise/cameraConnection.js";
import { getIO } from "../socket/socket.js"; // socket.io instance
import Logging from "../library/Logging.js";
import config from "../config/config.js";
import { AccountStatus } from "../utils/enums/index.js";

const TEMP_DIR = path.join(os.tmpdir(), "camera-uploads");
if (!fs.existsSync(TEMP_DIR)) fs.mkdirSync(TEMP_DIR, { recursive: true });

// âœ… LOCAL:  FTP_HOST=127.0.0.1  FTP_PASV_URL=127.0.0.1
// âœ… VPS:    FTP_HOST=0.0.0.0    FTP_PASV_URL=YOUR_PUBLIC_IP
const FTP_HOST = config.ftp.host;
const FTP_PORT = parseInt(config.ftp.port);
const FTP_PASV_URL = config.ftp.pasvUrl;
const FTP_PASV_MIN = config.ftp.pasvMin;
const FTP_PASV_MAX = config.ftp.pasvMax;

const ftpServer = new FtpSrv(`ftp://${FTP_HOST}:${FTP_PORT}`, {
  pasv_url: FTP_PASV_URL,
  pasv_min: FTP_PASV_MIN,
  pasv_max: FTP_PASV_MAX,
  anonymous: false,
  greeting: ["FindMyPhotos Camera Upload Server"],
  timeout: 0,
});

// âœ… Track active connections: Map<connectionId, {cameraConnectionId, enterpriseClientId}>
const activeConnections = new Map();

ftpServer.on(
  "login",
  async ({ connection, username, password }, resolve, reject) => {
    try {
      // 1. Validate camera token
      const cameraToken = await CameraToken.findOne({
        ftpUsername: username,
        ftpPassword: password,
        status: AccountStatus.ACTIVATE,
        deletedAt: null,
      });

      if (!cameraToken) {
        Logging.warn(`âŒ FTP Login failed: unknown token "${username}"`);
        return reject(new Error("Invalid camera credentials"));
      }

      // 2. Get camera IP
      const cameraIP = connection.ip || "unknown";

      // 3. Upsert camera connection record
      const cameraConn = await CameraConnection.findOneAndUpdate(
        { cameraTokenId: cameraToken._id },
        {
          enterpriseClientId: cameraToken.enterpriseClientId,
          cameraTokenId: cameraToken._id,
          tokenName: cameraToken.tokenName,
          cameraIP,
          isOnline: true,
          connectedAt: new Date(),
          lastSeenAt: new Date(),
          disconnectedAt: null,
        },
        { upsert: true, new: true },
      );

      // 4. Track this FTP connection
      const connId = connection.id || Date.now().toString();
      activeConnections.set(connId, {
        cameraConnectionId: cameraConn._id,
        enterpriseClientId: cameraToken.enterpriseClientId.toString(),
        cameraTokenId: cameraToken._id,
      });

      // 5. âœ… Emit socket event â†’ dashboard updates in real time
      const io = getIO();
      io.to(`client_${cameraToken.enterpriseClientId}`).emit(
        "camera_connected",
        {
          cameraConnectionId: cameraConn._id,
          tokenName: cameraToken.tokenName,
          cameraIP,
          isOnline: true,
          isUploadEnabled: cameraConn.isUploadEnabled,
          assignedEventId: cameraConn.assignedEventId,
          assignedAlbumId: cameraConn.assignedAlbumId,
          connectedAt: cameraConn.connectedAt,
        },
      );

      Logging.success(
        `ðŸ“· Camera connected: "${cameraToken.tokenName}" (${cameraIP}) â†’ Client: ${cameraToken.enterpriseClientId}`,
      );

      // 6. Set temp dir for this camera
      const camTempDir = path.join(TEMP_DIR, cameraConn._id.toString());
      if (!fs.existsSync(camTempDir))
        fs.mkdirSync(camTempDir, { recursive: true });

      resolve({ fs: camTempDir, root: camTempDir });

      // âœ… 7. STOR event â€” fires every time camera sends a photo
      connection.on("STOR", async (error, filePath) => {
        if (error) {
          Logging.error("FTP STOR error:", error.message);
          return;
        }

        const tracked = activeConnections.get(connId);
        if (!tracked) return;

        Logging.info(
          `ðŸ“¸ New file received from camera: ${path.basename(filePath)}`,
        );

        // âœ… Check if upload is enabled for this camera
        const camState = await CameraConnection.findById(
          tracked.cameraConnectionId,
        )
          .select("isUploadEnabled assignedEventId assignedAlbumId")
          .lean();

        if (!camState?.isUploadEnabled) {
          Logging.warn(
            `â¸ï¸ Upload disabled for camera â€” skipping: ${path.basename(filePath)}`,
          );

          // Delete temp file if upload disabled
          if (fs.existsSync(filePath)) fs.unlinkSync(filePath);
          return;
        }

        if (!camState?.assignedEventId || !camState?.assignedAlbumId) {
          Logging.warn(
            `âš ï¸ No event/album assigned â€” skipping: ${path.basename(filePath)}`,
          );
          if (fs.existsSync(filePath)) fs.unlinkSync(filePath);
          return;
        }

        // ðŸ“Œ Upload processing will be added here in next step
        // processCameraUpload({ filePath, ...tracked, ...camState })
        Logging.info(`âœ… File ready for processing: ${filePath}`);
      });

      // âœ… 8. Listen for disconnect
      connection.on("close", async () => {
        const tracked = activeConnections.get(connId);
        if (!tracked) return;

        await CameraConnection.findByIdAndUpdate(tracked.cameraConnectionId, {
          isOnline: false,
          disconnectedAt: new Date(),
          lastSeenAt: new Date(),
        });

        const io = getIO();
        io.to(`client_${tracked.enterpriseClientId}`).emit(
          "camera_disconnected",
          {
            cameraConnectionId: tracked.cameraConnectionId,
            isOnline: false,
            disconnectedAt: new Date(),
          },
        );

        activeConnections.delete(connId);
        Logging.success(`ðŸ“· Camera disconnected: "${cameraToken.tokenName}"`);
      });
    } catch (error) {
      Logging.error("FTP login error:", error.message);
      reject(new Error("Server error during authentication"));
    }
  },
);

ftpServer.on("client-error", ({ connection, error }) => {
  Logging.error("FTP Client Error:", error.message);
});

export const startFtpServer = () => {
  ftpServer
    .listen()
    .then(() => {
      Logging.success(`ðŸ“· FTP Camera Server â†’ ftp://${FTP_HOST}:${FTP_PORT}`);
      Logging.success(`ðŸ“¡ Passive mode IP: ${FTP_PASV_URL}`);
    })
    .catch((err) => {
      Logging.error("âŒ FTP Server failed to start:", err.message);
    });
};

export { activeConnections };
export default ftpServer;




// src/socket/socket.js
import { Server } from "socket.io";
import config from "../config/config.js";
import Logging from "../library/Logging.js";

let io = null;

export const initSocket = (httpServer) => {
  const allowedOrigins = config.origin.split(",");

  io = new Server(httpServer, {
    cors: {
      origin: allowedOrigins,
      credentials: true,
      methods: ["GET", "POST"],
    },
    transports: ["websocket", "polling"],
  });

  io.on("connection", (socket) => {
    Logging.info(`ðŸ”Œ Socket connected: ${socket.id}`);

    // âœ… Client joins their own room to receive camera events
    socket.on("join_client_room", ({ enterpriseClientId }) => {
      if (!enterpriseClientId) return;
      socket.join(`client_${enterpriseClientId}`);
      Logging.info(`ðŸ“· Camera room joined: client_${enterpriseClientId}`);
    });

    socket.on("disconnect", (reason) => {
      Logging.info(`ðŸ”Œ Socket disconnected: ${socket.id} (${reason})`);
    });

    socket.on("error", (err) => {
      Logging.error(`ðŸ”Œ Socket error: ${err.message}`);
    });
  });

  Logging.info("âœ… Socket.IO initialized");
  return io;
};

export const getIO = () => {
  if (!io) throw new Error("Socket.IO not initialized yet");
  return io;
};

export default { initSocket, getIO };
