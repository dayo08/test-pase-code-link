import mongoose from "mongoose";
import HTTP from "../../constants/httpStatusCodes.js";
import constants from "../../constants/messageConstants.js";
import ClientPackage from "../../models/enterprise/clientPackage.js";
import Event from "../../models/enterprise/event.js";
import UserEventVisitHistory from "../../models/user/userEventVisitHistory.js";
import { EventStatus } from "../../utils/enums/index.js";
import { jsonOne, throwHttpError } from "../../utils/generalUtils.js";

const getDashboardData = async (req, res, next) => {
  try {
    const { id: enterpriseClientId } = req["tokenPayload"];

    // 1. Get Current Active Package
    const currentPackage = await ClientPackage.findOne({
      enterpriseClientId,
      // isActive: true,
      // status: ClientPackageStatus.ACTIVE,
    })
      .populate(
        "packageId",
        "packageName totalPhotoMB eventLimit imageLimitPerAlbum validityInDays"
      )
      .lean();

    if (!currentPackage) {
      return throwHttpError(
        "eventId",
        constants.event.activePackage,
        HTTP.BAD_REQUEST
      );
    }

    // Combined aggregation query for events data and recent events
    const [eventsData] = await Promise.all([
      Event.aggregate([
        {
          $match: {
            enterpriseClientId: new mongoose.Types.ObjectId(enterpriseClientId),
            deletedAt: null,
          },
        },
        {
          $facet: {
            // Stats calculation
            stats: [
              {
                $group: {
                  _id: null,
                  totalEvents: { $sum: 1 },
                  activeEvents: {
                    $sum: {
                      $cond: [{ $eq: ["$status", EventStatus.ACTIVE] }, 1, 0],
                    },
                  },
                  archivedEvents: {
                    $sum: {
                      $cond: [{ $eq: ["$status", EventStatus.ARCHIVED] }, 1, 0],
                    },
                  },
                  draftEvents: {
                    $sum: {
                      $cond: [{ $eq: ["$status", EventStatus.DRAFT] }, 1, 0],
                    },
                  },
                  totalMBUsed: { $sum: "$totalMBUsed" },
                  totalAlbums: { $sum: "$totalAlbums" },
                  totalPhotos: { $sum: "$totalPhotos" },
                },
              },
            ],
            // Recent events
            recent: [
              { $sort: { createdAt: -1 } },
              {
                $project: {
                  eventName: 1,
                  eventStartDate: 1,
                  createdAt: 1,
                  totalAlbums: 1,
                  totalPhotos: 1,
                  totalMBUsed: 1,
                  status: 1,
                  archivedAt: 1,
                },
              },
            ],
          },
        },
        {
          $project: {
            stats: { $arrayElemAt: ["$stats", 0] },
            recentEvents: "$recent",
          },
        },
      ]),
    ]);

    // Extract data from aggregation results
    const stats = eventsData[0]?.stats || {
      totalEvents: 0,
      activeEvents: 0,
      archivedEvents: 0,
      draftEvents: 0,
      totalMBUsed: 0,
      totalAlbums: 0,
      totalPhotos: 0,
    };

    const recentEventsData = eventsData[0]?.recentEvents || [];

    // Calculate remaining days
    const now = new Date();
    const endDate = new Date(currentPackage.endDate);
    const daysRemaining = Math.ceil((endDate - now) / (1000 * 60 * 60 * 24));

    // Prepare Dashboard Response
    const dashboardData = {
      currentPackage: {
        packageName: currentPackage.packageId.packageName,
        totalPhotoMB: currentPackage.packageId.totalPhotoMB,
        eventLimit: currentPackage.packageId.eventLimit,
        imageLimitPerAlbum: currentPackage.packageId.imageLimitPerAlbum,
        validityInDays: currentPackage.packageId.validityInDays,

        status: currentPackage.status.toLowerCase(),
        startDate: currentPackage.startDate,
        endDate: currentPackage.endDate,
        daysRemaining: Math.max(0, daysRemaining),
        isTrial: currentPackage.isTrial,
        _id: currentPackage.packageId._id,
      },
      usage: {
        totalMBUsed: Math.max(0, Math.round(stats.totalMBUsed * 100) / 100),
        totalPhotosUploaded: Math.max(0, stats.totalPhotos),
        totalAlbumsCreated: Math.max(0, stats.totalAlbums),
        totalEventsCreated: Math.max(0, stats.totalEvents),
        activeEvents: Math.max(0, stats.activeEvents),
        archivedEvents: Math.max(0, stats.archivedEvents),
        draftEvents: Math.max(0, stats.draftEvents),
      },
      storageUsage: [
        {
          name: "Used Storage",
          value: Math.max(0, Math.round(stats.totalMBUsed * 100) / 100),
          color: "#343148",
        },
        {
          name: "Available Storage",
          value: Math.max(
            0,
            Math.round(
              (currentPackage.packageId.totalPhotoMB - stats.totalMBUsed) * 100
            ) / 100
          ),
          color: "#d7c39d",
        },
      ],
      recentEvents: recentEventsData.map((event) => ({
        name: event.eventName,
        date: event.eventStartDate || event.createdAt,
        albums: Math.max(0, event.totalAlbums),
        photos: Math.max(0, event.totalPhotos),
        status: event.status,
        mbUsed: Math.max(0, Math.round(event.totalMBUsed * 100) / 100),
        _id: event._id,
      })),
      usagePercentages: {
        storage: Math.min(
          100,
          Math.max(
            0,
            Math.round(
              (stats.totalMBUsed / currentPackage.packageId.totalPhotoMB) * 100
            )
          )
        ),
        events: Math.min(
          100,
          Math.max(
            0,
            Math.round(
              (stats.totalEvents / currentPackage.packageId.eventLimit) * 100
            )
          )
        ),
        avgImagesPerAlbum: Math.min(
          100,
          Math.max(
            0,
            stats.totalAlbums > 0
              ? Math.round(
                  (stats.totalPhotos /
                    stats.totalAlbums /
                    currentPackage.packageId.imageLimitPerAlbum) *
                    100
                )
              : 0
          )
        ),
      },
    };

    return jsonOne(res, HTTP.SUCCESS, dashboardData);
  } catch (error) {
    next(error);
  }
};

const getEventVisitStats = async (req, res, next) => {
  try {
    const { eventId } = req.params;

    // Aggregate pipeline to get all statistics in a single query
    const result = await UserEventVisitHistory.aggregate([
      // Match after unwind is sufficient since we have an index
      { $unwind: "$visitedEvents" },
      {
        $match: {
          "visitedEvents.eventId": new mongoose.Types.ObjectId(eventId),
        },
      },
      {
        $group: {
          _id: null,
          totalVisitors: { $sum: 1 },
          totalSelfiesTaken: {
            $sum: { $size: "$visitedEvents.selfies" },
          },
          lastUpdated: { $min: "$visitedEvents.firstVisitedAt" },
        },
      },
      {
        $project: {
          _id: 0,
          totalVisitors: 1,
          totalSelfiesTaken: 1,
          lastUpdated: 1,
        },
      },
    ]);

    // If no results, return zeros
    const stats = result[0] || {
      totalVisitors: 0,
      totalSelfiesTaken: 0,
      lastUpdated: null,
    };
    return jsonOne(res, HTTP.SUCCESS, stats);
  } catch (error) {
    next(error);
  }
};

export default { getDashboardData, getEventVisitStats };
