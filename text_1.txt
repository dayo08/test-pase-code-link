import crypto from "crypto";
import CameraToken from "../../models/enterprise/cameraToken.js";
import CameraConnection from "../../models/enterprise/cameraConnection.js";
import config from "../../config/config.js";
import { jsonOne, throwHttpError } from "../../utils/generalUtils.js";
import HTTP from "../../constants/httpStatusCodes.js";
import { getIO } from "../../socket/socket.js";
import { AccountStatus } from "../../utils/enums/index.js";

// ✅ Generate new camera token (photographer does this once per camera)
const createCameraToken = async (req, res, next) => {
  try {
    const { id: enterpriseClientId } = req.tokenPayload;
    const { tokenName } = req.body; // e.g. "Canon R5 - Main Camera"

    // Generate unique FTP credentials
    const ftpUsername = `cam_${crypto.randomBytes(6).toString("hex")}`; // cam_a3f9b2c1d4e5
    const ftpPassword = crypto.randomBytes(8).toString("hex"); // b2c1d4e5f6a7b8c9

    const token = await CameraToken.create({
      enterpriseClientId,
      tokenName,
      ftpUsername,
      ftpPassword,
    });

    return jsonOne(res, HTTP.SUCCESS, {
      _id: token._id,
      tokenName: token.tokenName,
      ftpCredentials: {
        host: config.ftp.publicHost,
        port: config.ftp.port,
        username: ftpUsername,
        password: ftpPassword,
      },
      cameraSetupGuide: {
        canon:
          "Menu → Network → FTP Transfer Settings → enter host/port/user/pass",
        nikon: "Menu → Network → Connect to FTP Server → enter credentials",
        sony: "Menu → Network → FTP Transfer Func → Server Settings",
        fujifilm: "Menu → Wireless Settings → FTP Uploading → Server Settings",
      },
    });
  } catch (error) {
    next(error);
  }
};

// ✅ Get all cameras of this client (connected + offline)
const getCameraList = async (req, res, next) => {
  try {
    const { id: enterpriseClientId } = req.tokenPayload;

    const cameras = await CameraConnection.find({ enterpriseClientId })
      .populate("assignedEventId", "eventName slug")
      .populate("assignedAlbumId", "albumName totalImages")
      .sort({ isOnline: -1, lastSeenAt: -1 })
      .lean();

    return jsonOne(res, HTTP.SUCCESS, cameras);
  } catch (error) {
    next(error);
  }
};

// ✅ Assign event + album to camera
const assignEventAlbum = async (req, res, next) => {
  try {
    const { cameraConnectionId } = req.params;
    const { assignedEventId, assignedAlbumId } = req.body;
    const { id: enterpriseClientId } = req.tokenPayload;

    const camera = await CameraConnection.findOneAndUpdate(
      { _id: cameraConnectionId, enterpriseClientId },
      { assignedEventId, assignedAlbumId },
      { new: true },
    )
      .populate("assignedEventId", "eventName")
      .populate("assignedAlbumId", "albumName");

    if (!camera) {
      return throwHttpError("not_found", "Camera not found", HTTP.NOT_FOUND);
    }

    // ✅ Emit update to dashboard
    const io = getIO();
    io.to(`client_${enterpriseClientId}`).emit("camera_updated", {
      cameraConnectionId,
      assignedEventId: camera.assignedEventId,
      assignedAlbumId: camera.assignedAlbumId,
    });

    return jsonOne(res, HTTP.SUCCESS, camera);
  } catch (error) {
    next(error);
  }
};

// ✅ Enable / Disable upload toggle
const toggleCameraUpload = async (req, res, next) => {
  try {
    const { cameraConnectionId } = req.params;
    const { id: enterpriseClientId } = req.tokenPayload;

    const camera = await CameraConnection.findOne({
      _id: cameraConnectionId,
      enterpriseClientId,
    });

    if (!camera) {
      return throwHttpError("not_found", "Camera not found", HTTP.NOT_FOUND);
    }

    camera.isUploadEnabled = !camera.isUploadEnabled;
    await camera.save();

    // ✅ Emit toggle to dashboard
    const io = getIO();
    io.to(`client_${enterpriseClientId}`).emit("camera_updated", {
      cameraConnectionId,
      isUploadEnabled: camera.isUploadEnabled,
    });

    return jsonOne(res, HTTP.SUCCESS, {
      cameraConnectionId,
      isUploadEnabled: camera.isUploadEnabled,
    });
  } catch (error) {
    next(error);
  }
};

// ✅ Delete camera token
const deleteCameraToken = async (req, res, next) => {
  try {
    const { tokenId } = req.params;
    const { id: enterpriseClientId } = req.tokenPayload;

    await CameraToken.findOneAndUpdate(
      { _id: tokenId, enterpriseClientId },
      { deletedAt: new Date(), status: AccountStatus.DEACTIVE },
    );

    await CameraConnection.findOneAndUpdate(
      { cameraTokenId: tokenId },
      { isOnline: false },
    );

    return jsonOne(res, HTTP.SUCCESS, {}, "Camera removed");
  } catch (error) {
    next(error);
  }
};

export default {
  createCameraToken,
  getCameraList,
  assignEventAlbum,
  toggleCameraUpload,
  deleteCameraToken,
};



import { Router } from "express";
import { cameraController } from "../../../controller/client/index.js";
import auth from "../../../middlewares/authMiddleware.js";
import permit from "../../../middlewares/permissionMiddleware.js";
import validate from "../../../middlewares/validationMiddleware.js";
import { clientRole } from "../../../utils/generalUtils.js";
import { validateCookie } from "../../../validators/authValidator.js";
import { resourceIds } from "../../../validators/generalValidators.js";
import { requiredTextField } from "../../../validators/venueValidators.js";

const _router = Router({
  mergeParams: true,
});

/** Get All cameras */
_router
  .route("/fetchAll")
  .get(
    validate([validateCookie("client_session")]),
    auth,
    permit(clientRole),
    cameraController.getCameraList,
  );

/** generate FTP creds  */
_router
  .route("/token")
  .post(
    validate([
      validateCookie("client_session"),
      requiredTextField("tokenName", "Token Name"),
    ]),
    auth,
    permit(clientRole),
    cameraController.createCameraToken,
  );

/** assign event+album  */
_router
  .route("/:cameraConnectionId/assign")
  .patch(
    validate([
      validateCookie("client_session"),
      resourceIds("cameraConnectionId", "param"),
      resourceIds("assignedEventId", "body"),
      resourceIds("assignedAlbumId", "body"),
    ]),
    auth,
    permit(clientRole),
    cameraController.assignEventAlbum,
  );

/*** enable/disable ***/
_router
  .route("/:cameraConnectionId/toggle")
  .patch(
    validate([
      validateCookie("client_session"),
      resourceIds("cameraConnectionId", "param"),
    ]),
    auth,
    permit(clientRole),
    cameraController.toggleCameraUpload,
  );

/** delete token */
_router
  .route("/token/:tokenId")
  .delete(
    validate([
      validateCookie("client_session"),
      resourceIds("tokenId", "param"),
    ]),
    auth,
    permit(clientRole),
    cameraController.deleteCameraToken,
  );

export const router = _router;
