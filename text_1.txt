import FtpSrv from "ftp-srv";
import path from "path";
import fs from "fs";
import os from "os";
import CameraToken from "../models/enterprise/cameraToken.js";
import CameraConnection from "../models/enterprise/cameraConnection.js";
import { getIO } from "../socket/socket.js"; // socket.io instance
import Logging from "../library/Logging.js";
import config from "../config/config.js";

const TEMP_DIR = path.join(os.tmpdir(), "camera-uploads");
if (!fs.existsSync(TEMP_DIR)) fs.mkdirSync(TEMP_DIR, { recursive: true });

// ‚úÖ LOCAL:  FTP_HOST=127.0.0.1  FTP_PASV_URL=127.0.0.1
// ‚úÖ VPS:    FTP_HOST=0.0.0.0    FTP_PASV_URL=YOUR_PUBLIC_IP
const FTP_HOST = config.ftp.host;
const FTP_PORT = parseInt(config.ftp.port);
const FTP_PASV_URL = config.ftp.pasvUrl;
const FTP_PASV_MIN = config.ftp.pasvMin;
const FTP_PASV_MAX = config.ftp.pasvMax;

const ftpServer = new FtpSrv(`ftp://${FTP_HOST}:${FTP_PORT}`, {
  pasv_url: FTP_PASV_URL,
  pasv_min: FTP_PASV_MIN,
  pasv_max: FTP_PASV_MAX,
  anonymous: false,
  greeting: ["FindMyPhotos Camera Upload Server"],
  timeout: 0,
});

// ‚úÖ Track active connections: Map<connectionId, {cameraConnectionId, enterpriseClientId}>
const activeConnections = new Map();

ftpServer.on(
  "login",
  async ({ connection, username, password }, resolve, reject) => {
    try {
      // 1. Validate camera token
      const cameraToken = await CameraToken.findOne({
        ftpUsername: username,
        ftpPassword: password,
        status: "activate",
        deletedAt: null,
      });

      if (!cameraToken) {
        Logging.warn(`‚ùå FTP Login failed: unknown token "${username}"`);
        return reject(new Error("Invalid camera credentials"));
      }

      // 2. Get camera IP
      const cameraIP = connection.ip || "unknown";

      // 3. Upsert camera connection record
      const cameraConn = await CameraConnection.findOneAndUpdate(
        { cameraTokenId: cameraToken._id },
        {
          enterpriseClientId: cameraToken.enterpriseClientId,
          cameraTokenId: cameraToken._id,
          tokenName: cameraToken.tokenName,
          cameraIP,
          isOnline: true,
          connectedAt: new Date(),
          lastSeenAt: new Date(),
          disconnectedAt: null,
        },
        { upsert: true, new: true },
      );

      // 4. Track this FTP connection
      const connId = connection.id || Date.now().toString();
      activeConnections.set(connId, {
        cameraConnectionId: cameraConn._id,
        enterpriseClientId: cameraToken.enterpriseClientId.toString(),
        cameraTokenId: cameraToken._id,
      });

      // 5. ‚úÖ Emit socket event ‚Üí dashboard updates in real time
      const io = getIO();
      io.to(`client_${cameraToken.enterpriseClientId}`).emit(
        "camera_connected",
        {
          cameraConnectionId: cameraConn._id,
          tokenName: cameraToken.tokenName,
          cameraIP,
          isOnline: true,
          isUploadEnabled: cameraConn.isUploadEnabled,
          assignedEventId: cameraConn.assignedEventId,
          assignedAlbumId: cameraConn.assignedAlbumId,
          connectedAt: cameraConn.connectedAt,
        },
      );

      Logging.success(
        `üì∑ Camera connected: "${cameraToken.tokenName}" (${cameraIP}) ‚Üí Client: ${cameraToken.enterpriseClientId}`,
      );

      // 6. Set temp dir for this camera
      const camTempDir = path.join(TEMP_DIR, cameraConn._id.toString());
      if (!fs.existsSync(camTempDir))
        fs.mkdirSync(camTempDir, { recursive: true });

      resolve({ fs: camTempDir, root: camTempDir });

      // 7. Listen for disconnect
      connection.on("close", async () => {
        const tracked = activeConnections.get(connId);
        if (!tracked) return;

        await CameraConnection.findByIdAndUpdate(tracked.cameraConnectionId, {
          isOnline: false,
          disconnectedAt: new Date(),
          lastSeenAt: new Date(),
        });

        const io = getIO();
        io.to(`client_${tracked.enterpriseClientId}`).emit(
          "camera_disconnected",
          {
            cameraConnectionId: tracked.cameraConnectionId,
            isOnline: false,
            disconnectedAt: new Date(),
          },
        );

        activeConnections.delete(connId);
        Logging.success(`üì∑ Camera disconnected: "${cameraToken.tokenName}"`);
      });

      connection.on("close", () => clearInterval(heartbeat));
    } catch (error) {
      Logging.error("FTP login error:", error.message);
      reject(new Error("Server error during authentication"));
    }
  },
);

ftpServer.on("client-error", ({ connection, error }) => {
  Logging.error("FTP Client Error:", error.message);
});

export const startFtpServer = () => {
  ftpServer
    .listen()
    .then(() => {
      Logging.success(`üì∑ FTP Camera Server ‚Üí ftp://${FTP_HOST}:${FTP_PORT}`);
      Logging.success(`üì° Passive mode IP: ${FTP_PASV_URL}`);
    })
    .catch((err) => {
      Logging.error("‚ùå FTP Server failed to start:", err.message);
    });
};

export { activeConnections };
export default ftpServer;
